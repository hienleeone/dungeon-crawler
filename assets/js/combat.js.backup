// combat.js (FULL - server-side authoritative)

// DOM + flags
const combatPanel = document.querySelector("#combatPanel");
let enemyDead = false;
let playerDead = false;

// Combat backlog (messages to show)
const combatBacklog = [];

// Combat timing (for display only)
let combatSeconds = 0;
let combatTimer = null;

// ---------------- Helper: add log & update ----------------
const addCombatLog = (message) => {
  combatBacklog.push(message);
  updateCombatLog();
};

const updateCombatLog = () => {
  let combatLogBox = document.getElementById("combatLogBox");
  if (!combatLogBox) return;
  combatLogBox.innerHTML = "";

  for (let message of combatBacklog) {
    let logElement = document.createElement("p");
    logElement.innerHTML = message;
    combatLogBox.appendChild(logElement);
  }

  if (enemyDead) {
    let button = document.createElement("div");
    button.className = "decision-panel";
    button.innerHTML = `<button id="battleButton">Nhận</button>`;
    combatLogBox.appendChild(button);
  }

  if (playerDead) {
    let button = document.createElement("div");
    button.className = "decision-panel";
    button.innerHTML = `<button id="battleButton">Quay Lại</button>`;
    combatLogBox.appendChild(button);
  }

  combatLogBox.scrollTop = combatLogBox.scrollHeight;

  // Hook battleButton only once (guard)
  const btn = document.getElementById("battleButton");
  if (btn) {
    btn.onclick = () => {
      sfxConfirm && sfxConfirm.play();
      if (playerDead) {
        // Return to title / reset (same as original behavior)
        playerDead = false;
        let dimDungeon = document.querySelector('#dungeon-main');
        if (dimDungeon) {
          dimDungeon.style.filter = "brightness(100%)";
          dimDungeon.style.display = "none";
        }
        combatPanel.style.display = "none";
        runLoad && runLoad("title-screen", "flex");
        clearInterval(dungeonTimer);
        clearInterval(playTimer);
        progressReset && progressReset();
      } else if (enemyDead) {
        // Close fight and return to dungeon exploration
        let dimDungeon = document.querySelector('#dungeon-main');
        if (dimDungeon) {
          dimDungeon.style.filter = "brightness(100%)";
        }
        bgmDungeon && bgmDungeon.play();
        dungeon.status.event = false;
        combatPanel.style.display = "none";
        enemyDead = false;
        combatBacklog.length = 0;
      }
    };
  }
};

// ---------------- UI helpers ----------------
const showCombatInfo = () => {
  document.querySelector('#combatPanel').innerHTML = `
    <div class="content">
        <div class="battle-info-panel center" id="enemyPanel">
            <p id="enemy-title">${enemy.name} Lv.${enemy.lvl}</p>
            <div class="battle-bar empty-bar hp bb-hp">
                <div class="battle-bar dmg bb-hp" id="enemy-hp-dmg"></div>
                <div class="battle-bar current bb-hp" id="enemy-hp-battle">
                    &nbsp${nFormatter(enemy.stats.hp)}/${nFormatter(enemy.stats.hpMax)}<br>(${enemy.stats.hpPercent}%)
                </div>
            </div>
            <div id="dmg-container"></div>
            <img src="./assets/sprites/${enemy.image.name}${enemy.image.type}" alt="${enemy.name}" width="${enemy.image.size}" id="enemy-sprite">
        </div>
        <div class="battle-info-panel primary-panel" id="playerPanel">
            <p id="player-combat-info"></p>
            <div class="battle-bar empty-bar bb-hp">
                <div class="battle-bar dmg bb-hp" id="player-hp-dmg"></div>
                <div class="battle-bar current bb-hp" id="player-hp-battle">
                    &nbsp${nFormatter(player.stats.hp)}/${nFormatter(player.stats.hpMax)}(${player.stats.hpPercent}%)
                </div>
            </div>
            <div class="battle-bar empty-bar bb-xb">
                <div class="battle-bar current bb-xb" id="player-exp-bar">exp</div>
            </div>
        </div>
        <div class="logBox primary-panel">
            <div id="combatLogBox"></div>
        </div>
    </div>
  `;
};

// ---------------- Combat timer (display only) ----------------
const combatCounter = () => {
  combatSeconds++;
};

// ---------------- Local combat functions (client-side) ----------------
const playerAttack = () => {
  if (enemyDead || playerDead) return;

  // Calculate damage
  const baseDmg = player.stats.atk || 10;
  const isCrit = Math.random() * 100 < (player.stats.critRate || 0);
  const critMultiplier = isCrit ? (1 + (player.stats.critDmg || 0) / 100) : 1;
  const damage = Math.floor(baseDmg * critMultiplier);

  // Apply damage to enemy
  enemy.stats.hp = Math.max(0, enemy.stats.hp - damage);
  
  // Log
  const critText = isCrit ? " <span style='color: #ff6b6b'>CRITICAL!</span>" : "";
  addCombatLog(`Bạn tấn công ${enemy.name} gây ${nFormatter(damage)} sát thương${critText}`);

  // Vampirism healing
  if (player.stats.vamp > 0) {
    const heal = Math.floor(damage * (player.stats.vamp / 100));
    player.stats.hp = Math.min(player.stats.hpMax, player.stats.hp + heal);
    addCombatLog(`Bạn hồi ${nFormatter(heal)} HP từ ma cà rồng`);
  }

  // Check enemy death
  if (enemy.stats.hp <= 0) {
    enemyDead = true;
    onEnemyDefeated();
  }
};

const enemyAttack = () => {
  if (enemyDead || playerDead) return;

  // Calculate damage
  const baseDmg = Math.max(1, enemy.stats.atk - (player.stats.def || 0));
  const damage = Math.floor(baseDmg);

  // Apply damage to player
  player.stats.hp = Math.max(0, player.stats.hp - damage);
  
  addCombatLog(`${enemy.name} tấn công bạn gây ${nFormatter(damage)} sát thương`);

  // Check player death
  if (player.stats.hp <= 0) {
    playerDead = true;
    onPlayerDefeated();
  }
};

// ---------------- Local combat resolution ----------------
async function resolveCombatLocal() {
  try {
    // Combat loop: alternate attacks until one dies
    let round = 0;
    const maxRounds = 100; // Prevent infinite loop

    while (!enemyDead && !playerDead && round < maxRounds) {
      round++;
      
      // Player attacks first
      playerAttack();
      if (enemyDead) break;

      // Small delay for readability
      await new Promise(r => setTimeout(r, 300));

      // Enemy counterattack
      enemyAttack();
      if (playerDead) break;

      await new Promise(r => setTimeout(r, 300));
    }

    // Update UI after combat
    playerLoadStats && playerLoadStats();
    enemyLoadStats && enemyLoadStats();

  } catch (err) {
    console.error('Lỗi combat:', err);
    addCombatLog('Lỗi xử lý combat. Vui lòng thử lại.');
  }
}

// ---------------- Combat result handlers ----------------
function onEnemyDefeated() {
  // Calculate rewards
  const goldGain = Math.floor(enemy.gold * (1 + Math.random() * 0.2)); // ±20%
  const xpGain = Math.floor(enemy.xp * (1 + Math.random() * 0.1)); // ±10%

  player.gold += goldGain;
  player.xp += xpGain;

  addCombatLog(`<span style='color: #4ade80'>Bạn đã đánh bại ${enemy.name}!</span>`);
  addCombatLog(`Nhận được ${nFormatter(goldGain)} vàng và ${nFormatter(xpGain)} exp`);

  // Check level up
  checkLevelUp();

  // Random drops
  if (enemy.drops && Math.random() < 0.3) { // 30% drop chance
    const drop = enemy.drops[Math.floor(Math.random() * enemy.drops.length)];
    player.inventory = player.inventory || { equipment: [], bag: [] };
    player.inventory.equipment.push(drop);
    addCombatLog(`${enemy.name} rơi <span style='color: #fbbf24'>${drop.name}</span>!`);
  }

  // Save progress
  savePlayerDataToFirebase && savePlayerDataToFirebase();
  
  enemyDead = true;
  updateCombatLog();
}

function onPlayerDefeated() {
  addCombatLog(`<span style='color: #ef4444'>Bạn đã thua trước ${enemy.name}...</span>`);
  addCombatLog(`Bạn mất 10% vàng hiện có.`);
  
  // Penalty: lose 10% gold
  player.gold = Math.floor(player.gold * 0.9);
  
  // Reset HP to 50%
  player.stats.hp = Math.floor(player.stats.hpMax * 0.5);
  
  playerDead = true;
  updateCombatLog();
}

function checkLevelUp() {
  const xpNeeded = 100 * Math.pow(1.5, player.lvl - 1);
  
  while (player.xp >= xpNeeded && player.lvl < 1000) {
    player.lvl++;
    player.xp -= xpNeeded;
    
    // Stat increases on level up
    player.baseStats.atk += 2;
    player.baseStats.def += 1;
    player.baseStats.hpMax += 10;
    player.stats.hp = player.stats.hpMax; // Full heal on level up
    
    addCombatLog(`<span style='color: #60a5fa'>LEVEL UP! Bạn đã lên cấp ${player.lvl}</span>`);
  }
}

// ---------------- Apply server result ----------------
function applyCombatResult(result) {
  if (!result) {
    addCombatLog('Không nhận được kết quả từ server.');
    endCombat();
    return;
  }

  // If server returns an authoritative player object, merge it.
  if (result.player && typeof result.player === 'object') {
    // Replace or merge safe fields from server
    // IMPORTANT: server is single source of truth for game-critical fields
    Object.assign(player, result.player);
    // If server returns nested stats object, make sure to update correctly
    if (result.player.stats) {
      player.stats = result.player.stats;
    }
    if (result.player.inventory) {
      player.inventory = result.player.inventory;
    }
  } else {
    // Fallback: update minimal fields returned
    if (typeof result.gold === 'number') player.gold = result.gold;
    if (typeof result.lvl === 'number') player.lvl = result.lvl;
    if (typeof result.xp === 'number') player.xp = result.xp;
  }

  // If server returns combatLog (array of strings), display them progressively
  if (Array.isArray(result.combatLog) && result.combatLog.length > 0) {
    // optional: animate logs with small delay for drama
    (async () => {
      for (let line of result.combatLog) {
        addCombatLog(line);
        // small delay to mimic pacing (200ms)
        await new Promise(r => setTimeout(r, 200));
      }
      finalizeAfterCombat(result);
    })();
  } else {
    // no combatLog provided: show short summary and finalize
    if (result.victory) addCombatLog(`Bạn đã đánh bại ${enemy.name}!`);
    else addCombatLog(`Bạn đã thua trước ${enemy.name}...`);

    addCombatLog(`Bạn nhận được ${nFormatter(result.goldGain || 0)} vàng và ${nFormatter(result.xpGain || 0)} exp.`);
    finalizeAfterCombat(result);
  }
}

// Final UI/state updates and closing steps after server result displayed
function finalizeAfterCombat(result) {
  // Drops
  if (Array.isArray(result.drops) && result.drops.length > 0) {
    player.inventory = player.inventory || { equipment: [] };
    for (let it of result.drops) {
      player.inventory.equipment.push(it);
      addCombatLog(`${enemy.name} rơi ${it.name} (${it.rarity}).`);
    }
  }

  // Set enemy hp to 0 on client UI (server determined death)
  enemy.stats.hp = 0;

  // Optional: if server returned new player.stats.hp, we already merged above.
  // If not, don't modify HP beyond what server told us.

  // Update UI
  playerLoadStats && playerLoadStats();
  enemyLoadStats && enemyLoadStats();

  // Show accept / return button
  enemyDead = !!result.victory;
  playerDead = !result.victory && !!result.playerDead; // if server informs death

  updateCombatLog();

  // End combat (stops timers, cleans up buffs)
  endCombat();
}

// ---------------- Start combat (client-side resolution) ----------------
const startCombat = async (battleMusic) => {
  // UI changes
  bgmDungeon && bgmDungeon.pause();
  sfxEncounter && sfxEncounter.play();
  battleMusic && battleMusic.play();
  player.inCombat = true;

  let dimDungeon = document.querySelector('#dungeon-main');
  if (dimDungeon) dimDungeon.style.filter = "brightness(50%)";

  playerLoadStats && playerLoadStats();
  enemyLoadStats && enemyLoadStats();

  dungeon.status.event = true;
  combatPanel.style.display = "flex";

  showCombatInfo();

  // Start display timer
  combatSeconds = 0;
  combatTimer = setInterval(combatCounter, 1000);

  // Resolve combat locally
  await resolveCombatLocal();
};

// ---------------- End combat cleanup ----------------
const endCombat = () => {
  try {
    bgmBattleMain && bgmBattleMain.stop();
    bgmBattleGuardian && bgmBattleGuardian.stop();
    bgmBattleBoss && bgmBattleBoss.stop();
  } catch (e) { /* ignore */ }

  sfxCombatEnd && sfxCombatEnd.play();
  player.inCombat = false;

  // Remove temporary buffs (client-only). IMPORTANT: do NOT call saveData()
  // because saveData may attempt to write game-critical fields. We only adjust local temp stats.
  if (player.skills && player.skills.includes("Rampager")) {
    objectValidation && objectValidation();
    player.baseStats.atk -= (player.tempStats ? player.tempStats.atk : 0) || 0;
    if (player.tempStats) player.tempStats.atk = 0;
  }
  if (player.skills && player.skills.includes("Blade Dance")) {
    objectValidation && objectValidation();
    player.baseStats.atkSpd -= (player.tempStats ? player.tempStats.atkSpd : 0) || 0;
    if (player.tempStats) player.tempStats.atkSpd = 0;
  }

  // Stops every timer in combat
  if (combatTimer) {
    clearInterval(combatTimer);
    combatTimer = null;
  }
  combatSeconds = 0;
};

// ---------------- Small utility: safe show on load ----------------
try {
  // expose for debugging if needed
  window.startCombatLocal = startCombat;
  window.resolveCombatLocal = resolveCombatLocal;
} catch (e) { /* ignore */ }
